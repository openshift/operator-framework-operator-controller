package check

import (
	"context"
	"errors"
	"fmt"

	"github.com/operator-framework/operator-registry/alpha/declcfg"
)

// AllCatalogChecks returns a list of all catalog checks to be performed.
func AllCatalogChecks() []CatalogCheck {
	return []CatalogCheck{
		CatalogHasNoBundleObjectProperties(),
		CatalogHasValidMetadataForChannelHeads(),
	}
}

// CatalogHasNoBundleObjectProperties verifies that no bundle has declares a olm.bundle.object property.
// From OpenShift 4.17+ bundles should no longer use the olm.bundle.object property.
//
// If a bundle has the olm.bundle.object property set, it might be used by the package server
// to serve metadata about the package which has a higher cost than using the olm.csv.metadata property
// resulting in critical performance issues.
//
// The command opm render --migrate-level bundle-object-to-csv-metadata and
// the command opm migrate --migrate-level bundle-object-to-csv-metadata will both do
// the migration from olm.bundle.object to olm.csv.metadata.
func CatalogHasNoBundleObjectProperties() CatalogCheck {
	return CatalogCheck{
		Name: "CatalogHasNoBundleObjectProperties",
		Fn: func(ctx context.Context, cfg declcfg.DeclarativeConfig) error {
			var errs []error
			for _, bundle := range cfg.Bundles {
				var found bool
				for _, prop := range bundle.Properties {
					if prop.Type == "olm.bundle.object" {
						found = true
					}
				}
				if found {
					errs = append(errs, fmt.Errorf("bundle %q in package %q has olm.bundle.object set",
						bundle.Name, bundle.Package))
				}
			}

			return errors.Join(errs...)
		},
	}
}

// CatalogHasValidMetadataForChannelHeads checks if the channel heads have olm.csv.metadata
// OLM Package Server (used by tooling such as the kubectl operator plugin and the OpenShift console)
// does require these properties to be able to serve metadata about the packages in a catalog.
//
// In order to satisfy the needs of the package server, catalog maintainers should use this property to
// include the CSV metadata for all bundles that are channel heads.
// As of `opm` version 1.28.0, this property is automatically generated by when migrating SQLite
// catalogs with `opm migrate` and when rendering SQLite catalogs and registry+v1 bundles with `opm render`.
// Catalogs containing `olm.csv.metadata` properties must be served by `opm` binaries
// with version at least `1.28.0`.
func CatalogHasValidMetadataForChannelHeads() CatalogCheck {
	return CatalogCheck{
		Name: "CatalogHasValidMetadataForChannelHeads",
		Fn: func(ctx context.Context, cfg declcfg.DeclarativeConfig) error {
			var errs []error
			packages, err := declcfg.ConvertToModel(cfg)
			if err != nil {
				return fmt.Errorf("unable to convert: %w", err)
			}

			for _, pkg := range packages {
				for _, ch := range pkg.Channels {
					channelHead, err := ch.Head()
					if err != nil {
						errs = append(errs, fmt.Errorf(
							"channel %q in package %q could not determine channel head: %v",
							ch.Name, pkg.Name, err))
						continue
					}

					var found bool
					for _, prop := range channelHead.Properties {
						if prop.Type == "olm.csv.metadata" {
							found = true
						}
					}
					if !found {
						errs = append(errs,
							fmt.Errorf("bundle %q in package %q is missing olm.csv.metadata",
								channelHead.Name,
								channelHead.Package.Name))

						// If we have a channel head without olm.csv.metadata we need to verify if the olm.bundle.object
						// property is set. If not, then it means that the opm render | migrate command could not
						// do the migration.
						found = false
						for _, prop := range channelHead.Properties {
							if prop.Type == "olm.bundle.object" {
								found = true
							}
						}

						if !found {
							errs = append(errs,
								fmt.Errorf("bundle %q in package %q is a head of channel and does not either "+
									"olm.csv.metadata or olm.bundle.object set",
									channelHead.Name,
									channelHead.Package.Name))
						}
					}
				}
			}

			return errors.Join(errs...)
		},
	}
}
